
Parent Component and Child Component Communication (Parent to Child):(Component Property Binding)
	To allow parent component to be able to bind to child component property using selector
		@Input exposed a property of a component to be accessed by parent component
		@Input makes the property bindable from outside.
		**This is getting somting into the component.
			
		Example(in learing-app):
			element property of server-element.component with alias srvElement exposed to parent component with @Input
				src\app\databind\server-element\server-element.component.ts
				@Input('srvElement') element: {type: string, name: string, content: string};
		
			Above srvElement property access in another component(databind.component) by property binding:
				src\app\databind\databind.component.html
				<app-server-element 
					*ngFor="let serverElement of serverElements" 
					[srvElement]="serverElement"></app-server-element>
				
Parent Component and Child Component Communication (Child to Parent):(Component Event Binding)		
	To allow child component to emit even to Parent, using Component Event Binding:
		1. Use event emitter(EventEmitter) to create custom events for the Component.
		2, EventEmitter takes a generic type object same as the type of object it wants to emmit.
			eg: new EventEmitter<{serverName: string, serverContent: string}>();
		3. To emit the event, trigger .emit method on the event emitter
			onAddServer() {
				//emit even call on serverCreated: EventEmitter
				this.serverCreated.emit({
				  serverName: this.newServerName, 
				  serverContent: this.newServerContent
				});
			  }
		4. @Output is using to make the event listenable from outside(child to communicate event signal to outside or parent component)
			**This is passing somting out of the component.
			
		Example(in learing-app):
			Event emitter created in Child component and annoted with @Output to make the even listenable
				src\app\databind\cockpit\cockpit.component.ts
				@Output() serverCreated = new EventEmitter<{serverName: string, serverContent: string}>();
				@Output('bpCreated') blueprintCreated = new EventEmitter<{serverName: string, serverContent: string}>();
				
			Trigger the event by emit method in (src\app\databind\cockpit\cockpit.component.ts) child component:
				onAddServer() {
					this.serverCreated.emit({
					  serverName: this.newServerName, 
					  serverContent: this.newServerContent
					});
				  }
					
			Listern to the event in parent component by event binding in (src\app\databind\databind.component.html):
				<app-cockpit 
				  (serverCreated)="onServerAdded($event)"
				  (bpCreated)="onBluprintAdded($event)"
				  ></app-cockpit>
				
ViewEncapsulation: to override elements generated by angular not to include default ettributes in the element
	In src\app\databind\server-element\server-element.component.ts
		@Component({
		  selector: 'app-server-element',
		  templateUrl: './server-element.component.html',
		  styleUrls: ['./server-element.component.css'],
		  encapsulation: ViewEncapsulation.None
		})
		
Local Reference:
	1. Local Reference can be included on any template on HTML as: #<local-ref-variable-name>
	2. This reference will hold a reference to the whole element its included, not just value
		<input type="text" class="form-control" #serverNameInput">
		<button class="btn btn-primary" (click)="onAddServer(serverNameInput)">Add Server</button>
	3. Here #serverNameInput holds reference to "input" element itself and can be passed and assessed as bloew in .ts.
		onAddServer(serverNameInput: HTMLInputElement) {
			console.log(serverNameInput);
			console.log(serverNameInput.value);
		  }
	4. Local reference helps to access any of the elements in the template(HTML) or pass it to Component(.ts) for use.
	
		
@ViewChild():
		1. @ViewChild can be used directly on type-script file to access a template element instead of passing local-reference as param.
		2. Unlike local-reference, element access using @ViewChild has type ElementRef
		
			Example(in learing-app):
				in src\app\databind\server-element\server-element.component.html, use a local-reference
					<div class="panel-heading" #heading>{{ element.name }}</div>
			
				In src\app\databind\server-element\server-element.component.ts, pass the selector name to @ViewChild
				@ViewChild('heading') header: ElementRef;
				
				//To access the template element refered using @ViewChild
				ngOnInit() {
					console.log('Text Content: ###'+this.header.nativeElement.textContent);
				  }
				
			
		@ViewChild() in Angular 8:
			In Angular 8, the @ViewChild() syntax which you'll see in the next lecture needs to be changed slightly:
			Instead of:
				@ViewChild('serverContentInput') serverContentInput: ElementRef;
			use
				@ViewChild('serverContentInput', {static: true}) serverContentInput: ElementRef;
			
			The same change (add { static: true } as a second argument) needs to be applied to ALL usages of @ViewChild() (and also @ContentChild() which you'll learn about later) IF you plan on accessing the selected element inside of ngOnInit().
			If you DON'T access the selected element in ngOnInit (but anywhere else in your component), set static: false instead!
			This is a temporary adjustment which will NOT be required anymore once Angular 9 is released!	
			
ng-content:	
	1. in src\app\databind\databind.component.html, put the content in between selector:
		<app-server-element *ngFor="let serverElement of serverElements" [srvElement]="serverElement">
			<p>
			  <strong *ngIf="element.type === 'server'" style="color: red">{{ element.content }}</strong>
			  <em *ngIf="element.type === 'blueprint'">{{ element.content }}</em>
			</p>
		</app-server-element>
	2. in 
		<div class="panel panel-default">
		  <!--Local reference #heading created-->
		  <div class="panel-heading" #heading>{{ element.name }}</div>
		  <div class="panel-body">
			<ng-content></ng-content>
		  </div>
		</div>
		
	3. Here the content between selector "app-server-element" will be projected or pushed to the location where <ng-content> is present.
	4. ng-content is a directive used to render content from outside.
	
	
Life Cycle Hooks:
	When a new component instanciated in angular, it gets thru some life cycle-hooks
	constructor() { console.log('1. constructor called...'); }
	ngOnChanges(changes: SimpleChanges){ console.log('2. ngOnChanges called...');  console.log(changes); }
	ngOnInit() { console.log('3. ngOnInit called...'); console.log('Text Content: ###'+this.header.nativeElement.textContent); }
	ngDoCheck(){ //Triggers when angular checks for any change in any component console.log('4. ngDoCheck called'); }
	ngAfterContentInit(){ //it executes only once after content initialization console.log('5. ngAfterContentInit called...') }
	ngAfterContentChecked(){ console.log('6. ngAfterContentChecked called...') }
	ngAfterViewInit(){ //it executes only once after content initialization 
		console.log('7. ngAfterViewInit called...') console.log('Text Content: ###'+this.header.nativeElement.textContent); 
	}
	ngAfterViewChecked(){ console.log('8. ngAfterViewChecked called...') }
	ngOnDestroy(){ console.log('9. ngOnDestroy called...') }
	
@ContentChild()
	@ContentChild() in Angular 8:
		In Angular 8, the @ContentChild() syntax which you'll see in the next lecture needs to be changed slightly:
		Instead of:
			@ContentChild('contentParagraph') paragraph: ElementRef;
			use
			@ContentChild('contentParagraph', {static: true}) paragraph: ElementRef;
		The same change (add { static: true } as a second argument) needs to be applied to ALL usages of @ContentChild() if you use the selected element inside of ngOnInit (as we do it in the lectures).
		If you DON'T use the selected element in ngOnInit, set static: false instead.
	
	
	
		
		
	
		
	
				
			
			
		
		